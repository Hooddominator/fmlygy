'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var _bind = Function.prototype.bind;

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _lineByLine = require('line-by-line');

var _lineByLine2 = _interopRequireDefault(_lineByLine);

var _log = require('./log');

var log = _interopRequireWildcard(_log);

var _Subtitle = require('./Subtitle');

var _Subtitle2 = _interopRequireDefault(_Subtitle);

var _Time = require('./Time');

var _Time2 = _interopRequireDefault(_Time);

var PHASE = { INDEX: 0, TIME: 1, TEXT: 2 };
var TIMES_REGEX = /^[^\d]*(\d+):(\d+):(\d+),(\d+)[^/d]+?(\d+):(\d+):(\d+),(\d+)[^\d]*$/;

function parseTimesFromLine(timeLineString) {
  var match = timeLineString.match(TIMES_REGEX);
  var startTime = new (_bind.apply(_Time2['default'], [null].concat(_toConsumableArray(match.slice(1, 5)))))();
  var endTime = new (_bind.apply(_Time2['default'], [null].concat(_toConsumableArray(match.slice(5, 9)))))();
  return { start: startTime, end: endTime };
}

var FileParser = (function () {
  function FileParser(filePath) {
    _classCallCheck(this, FileParser);

    this._filePath = filePath;
    this._subtitles = null;
  }

  _createClass(FileParser, [{
    key: 'getFilePath',
    value: function getFilePath() {
      return this._filePath;
    }
  }, {
    key: 'getSubtitles',
    value: function getSubtitles() {
      return this._subtitles;
    }
  }, {
    key: 'parse',
    value: function parse() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this._subtitles = [];
        var phase = PHASE.INDEX;
        var currentSubtitle = new _Subtitle2['default']();
        var lineIndex = 0;
        // Start a line-by-line reader
        var reader = new _lineByLine2['default'](_this._filePath);
        reader.on('err', reject);
        reader.on('line', function (line) {
          log.log('[' + phase + '] «' + line + '»');
          switch (phase) {
            case PHASE.INDEX:
              if (line.length === 0) {
                // Keep waiting
                break;
              }
              currentSubtitle.setIndex(parseInt(line, 10));
              phase = PHASE.TIME;
              break;
            case PHASE.TIME:
              var times = parseTimesFromLine(line);
              currentSubtitle.setStartTime(times.start);
              currentSubtitle.setEndTime(times.end);
              phase = PHASE.TEXT;
              break;
            case PHASE.TEXT:
              if (line.length === 0) {
                // Empty line
                if (currentSubtitle.getText().length === 0) {
                  // Haven't encountered any text yet, so this is just a slightly
                  // invalid SRT file - warn about it but carry on
                  log.log('WARNING [L' + lineIndex + ']: Expected non-empty line of text');
                } else {
                  // Reached end of text for this subtitle - finish up and add to
                  // the list
                  _this._subtitles.push(currentSubtitle);
                  currentSubtitle = new _Subtitle2['default']();
                  phase = PHASE.INDEX;
                }
                break;
              }
              currentSubtitle.addText(line);
              break;
          }
          lineIndex++;
        });
        reader.on('end', function () {
          return resolve(_this.getSubtitles());
        });
      });
    }
  }]);

  return FileParser;
})();

exports['default'] = FileParser;
module.exports = exports['default'];